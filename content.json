{"pages":[{"title":"Standing on the Shoulder of Giants","text":"动漫剪辑编程","link":"/about/index.html"}],"posts":[{"title":"el-element复合型输入框和动态删减框","text":"这里我碰到的一个需求是添加多个电话,所以我猜想用到了push数组，刚好el-element里面有用到动态增减表单项的组件查看源码，添加则是push一个空数组 data() { return { dynamicValidateForm: { domains: [{ value: &apos;&apos; }], email: &apos;&apos; } }; addDomain() { this.dynamicValidateForm.domains.push({ value: &apos;&apos;, key: Date.now() });删除则splice(index, 1)并返回一个删除后的数组 removeDomain(item) { var index = this.dynamicValidateForm.domains.indexOf(item) if (index !== -1) { this.dynamicValidateForm.domains.splice(index, 1) } }, 关于数组的方法push和splice使用差不多， push() 方法可向数组的末尾添加一个或多个元素，并返回新的数组。 arr.push(newelement1,newelement2,....,newelementX) splice不仅可以删除，还可以进行添加，返回新的数组 splice 是数组的一个方法，使用这个方法会改变原来的数组结构， arr.splice（index ，howmany ， itemX）；复合型输入框的使用 &lt;div style=&quot;margin-top: 15px;&quot;&gt; &lt;el-input placeholder=&quot;请输入内容&quot; v-model=&quot;input3&quot; class=&quot;input-with-select&quot;&gt; &lt;el-select v-model=&quot;select&quot; slot=&quot;prepend&quot; placeholder=&quot;请选择&quot;&gt; &lt;el-option label=&quot;餐厅名&quot; value=&quot;1&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;订单号&quot; value=&quot;2&quot;&gt;&lt;/el-option&gt; &lt;el-option label=&quot;用户电话&quot; value=&quot;3&quot;&gt;&lt;/el-option&gt; &lt;/el-select&gt; &lt;el-button slot=&quot;append&quot; icon=&quot;el-icon-search&quot;&gt;&lt;/el-button&gt; &lt;/el-input&gt; &lt;/div&gt;","link":"/2019/09/22/el-element复合型输入框和动态删减框/"},{"title":"css记录问题","text":"问题：适配不同分辨率的屏幕？ 媒体查询+百分比=栅格化 问题：让浮动元素不脱离父元素？ 在父元素清除浮动 问题：怎么最方便的使元素居中？ line-height属性只对行内元素生效，(行高-字体大小)/2=上边距=下边距 问题：父元素里有两个不同的字体 ，一个为20，一个为14，行高设为80，我想设置为元素总高为80，实际却为83，结果显示20字体元素的上下边距为30，14字体元素的上下边距为33。怎么使14字体不干扰呢？ 在14字体包裹的元素中在设置一个行高，就设置line-height：14px；将解决干扰。","link":"/2019/09/15/css记录/"},{"title":"git推送遇到的问题","text":"github无法推送的原因 该分支与远程从分支无相关联系 没给该分支设置上游远程节点 git branch --set-upstream-to=&lt;远程主机名&gt;/&lt;远程分支名&gt; &lt;本地分支名&gt; git的更新操作如果本地与远程大部分不一样，有合并冲突，需要先拉取合并，才能进行推送本地分支名与远程分支名的特殊情况 1.本地分支名与远程分支名不同时候 git push &lt;远程主机名&gt; &lt;本地分支名&gt;：&lt;远程分支名&gt; 若加-f 则强行本地覆盖2.本地分支名和远程分支名相同时候如果远程分支被省略，如上则表示将本地分支推送到与之存在追踪关系的远程分支（通常两者同名），如果该远程分支不存在，则会被新建 git push &lt;远程主机名&gt; &lt;本地分支名&gt; tip：省略本地分支名，则表示删除指定的远程分支 git push origin ：&lt;远程分支名&gt; git push origin","link":"/2019/09/15/git推送遇到的问题/"},{"title":"el-element的的表格填充数据","text":"在我从后台拿到一个这样的数据 data = { PersonInfo：{ id_card： }， Phone:[ { personDataId: phone_number: }, {} ], psAddress:[ {}, {} ] }由于el-table :data=”tableData”中的：data需要的数据类型是数组 这里我我将返回的数据push进tableData数组 data(){ return{ tableData: [] } } methods:{ this.tableData.push(res.data) } 这样就是tableData[{ [ {}, {} ], [ {}, {} ] }]但是考虑里里面数据的复杂性，不能像之前直接使用，在el-table-column中用prop属性来对应对象中的键名即可填入数据。 官方文档的数据形式 tableData: [{ date: &apos;2016-05-02&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1518 弄&apos; }, { date: &apos;2016-05-04&apos;, name: &apos;王小虎&apos;, address: &apos;上海市普陀区金沙江路 1517 弄&apos; } &lt;el-table-column prop=&quot;date&quot; label=&quot;日期&quot; width=&quot;180&quot;&gt; &lt;/el-table-column&gt;所以我们这里要用到solt插件和v-for循环 &lt;el-table-column label=&quot;ID号码&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;div&gt;{{scope.row.PersonInfo.id_card}}&lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt; &lt;el-table-column label=&quot;联系电话&quot;&gt; &lt;template slot-scope=&quot;scope&quot;&gt; &lt;div v-for=&quot; (item,personDataId) in scope.row.Phone&quot; :key=&quot;personDataId&quot;&gt; &lt;span&gt;{{item.phone_number}}&lt;/span&gt; &lt;/div&gt; &lt;/template&gt; &lt;/el-table-column&gt;","link":"/2019/09/22/el-element的的表格填充数据/"},{"title":"Git的常用命令","text":"git上传常用命令的基本流程 git init //初始化git仓库 git add . //将文件提交到暂存区 git commit -m &apos;说明&apos; git remote add [本地自定义远程仓库名] [远程仓库url] //建立远程仓库 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;拉取并合并 git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt; git pull=git fetch +git merge 推送 git push -u origin master //第一次将本地仓库推送到远程仓库 git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;总结 git pull/push &lt;远程主机名&gt; &lt;源地址&gt;:&lt;目的地址&gt;常用吗命令 git ls-files //查看暂存区文件 git diff //查看暂存区前后不同 git branch 分支名 //创建新的分支 git branch //查看分支 git branch -r //查看远程的分支名 git branch --set-upstream-to=&lt;远程主机名&gt;/&lt;远程分支名&gt; &lt;本地分支名&gt; //给该分支设置上游远程节点 git checkout -b 分支名 //创建新的分支并切换过去 git checkout 分支名 //切换到该分支 git init //初始化git仓库 git add 文件名 //提交该文件 git add . //提交仓库所有文件 git commit -m &quot;注释&quot; //提交暂存区的文件到版本库 git remote add [本地自定义远程仓库名] [远程仓库url] //建立远程仓库 git clone &lt;远程仓库地址&gt; //克隆该仓库的默认分支 git clone -b 分支名 &lt;远程仓库地址&gt; //克隆指定的分支","link":"/2019/09/15/git的常用命令/"},{"title":"关于json的联系","text":"前因：有个需求json格式的多条数据，所以今天在公司里做一个Array bb = [{name，age}，{name，age}]这样的数据类型,我通过调用arrayObject.push(newelement1，newelement2，….，newelementX)，来进行数据填充。在console台中非常完美的显示出来了，但是在进行表单提交数据到服务器的时候，数据的格式非常奇怪。 这里我举一个例子 shuzu = []，key ：value格式。shuzu ： bb 这时候上传的数据格式应该是shuzhu: [[0],[1],....,[X]],可是在数据被服务器拒绝。 经过排查，在http报文请求参数Form Data发现数据格式为shuzhu[0].name,shu[0].age,shu[1],name.shuzu[1].age 理想情况name和age属性应该一个值，而不应该是分散的。 出现这个问题因为我没有做json的序列化。 数组中的js对象没做序列化 [object,object] 做序列化： bb = &apos;[[0],[1],....,[X]]&apos; shuzu ：bb所以这里我要提到序列化的知识。 序列化是什么？ 百科的解释：序列化 (Serialization)是将对象的状态信息转换为可以存储或传输的形式的过程。 基本上所有的语言都有序列化对象的方法。“字符串”对于服务器端来说不管哪种语言都是可以识别的。 若作为网络的传输就是将js对象转换为字节流，将字节流转换回js对象 为什么要序列化呢？ 网络数据传输，可以直接发送字符串，但不能直接发送一个结构体。 网络上传输数据，因为发送端和接收端，通常不能保证是两边是相同的编程语言， 直接将结构体的数据整理成流发送过去，数据排序或者长度会跟你想象的不一样。序列化有什么作用呢？ 1.以某种存储形式使自定义对象持久化； 2.将对象从一个地方传递到另一个地方，序列化确实可以很好的跨语言平台 3.使程序更具维护性。通常的解决办法： 约定一个协议，协议规定好数据流中每个字节的含义。 发送端要保证按照协议要求组装好数据流。 接收端按照协议规定读取出里面的数据（解析）。通过上面序列化的概念，我们在回到JSON(JavaScript Object Notation)这个来讨论，json是一种轻量级的数据交换格式。 通过把任何JavaScript对象变成JSON，就是把这个对象序列化成一个JSON格式的字符串，这样才能够通过网络传递给其他计算机。 如果收到一个JSON格式的字符串，只需要把它反序列化成一个JavaScript对象，就可以在JavaScript中直接使用这个对象了。javascript内置了序列化函数JSON.stringify(),和反序列函数JSON.parse()1.JSON.stringify()示例 var xiaoming = { name: &apos;小明&apos;, age: 14, gender: true, height: 1.65, grade: null, &apos;middle-school&apos;: &apos;\\&quot;W3C\\&quot; Middle School&apos;, skills: [&apos;JavaScript&apos;, &apos;Java&apos;, &apos;Python&apos;, &apos;Lisp&apos;] }; var s = JSON.stringify(xiaoming); //&apos;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14,&quot;gender&quot;:true,&quot;height&quot;:1.65,&quot;grade&quot;:null,&quot;middle-school&quot;:&quot;\\&quot;W3C\\&quot; Middle School&quot;,&quot;skills&quot;:[&quot;JavaScript&quot;,&quot;Java&quot;,&quot;Python&quot;,&quot;Lisp&quot;]}&apos;2.JSON.parse()示例 JSON.parse(&apos;[1,2,3,true]&apos;); // [1, 2, 3, true] JSON.parse(&apos;{&quot;name&quot;:&quot;小明&quot;,&quot;age&quot;:14}&apos;); // Object {name: &apos;小明&apos;, age: 14} JSON.parse(&apos;true&apos;); // true JSON.parse(&apos;123.45&apos;); // 123.45使用场景1.向后台传递参数、接收后台返回值 如果后台返回的是一个String（Object序列化后返回），那么需要在js中使用parse转化为Object再使用； 如果返回的时候传递了类型，比如就是Object，那么直接使用就好2.在页面间传递数据，特别是数组时 需要使用序列化，否则IE会报错：不能执行已经释放Script的代码3.在进行本地存储时 存储在本地window.localStorage.setItem(key,value)存储的value是json序列化的字符串； 获取得到的window.localSorage.getItem(key)也是json序列化的字符串，需要经过json的反序列化进行使用（常见json序列化数组）额外知识点 类型 toString Object 返回”[object Object]” stringObject 返回字符串 NumberObject 把一个 Number 对象转换为一个字符串，并返回结果。 booleanObject 把一个逻辑值转换为字符串，并返回结果。 arrayObject 把数组转换为字符串，用逗号间隔，并返回结果 dateObject 把 Date 对象转换为字符串，并返回结果 自定义对象调用js 的 toString 方法，返回的不是对象序列化后的字符串，而是 [object Object] 字符串。这是因为自定义对象没有重写 toString 方法。 通过记录工作上的问题，学习知识，本文章的知识点来自网络上的各位前辈，仅作学习记录参考，感谢前辈们。更多帮助请参考廖雪峰","link":"/2019/09/17/关于json的联系/"},{"title":"vue的常用总结","text":"1.Vue的组件传递属性 vue父亲组件传递值的使用 父组件用到props给子组件传值，子组件只需要做一件事,那就是通过props接收 父组件： 子组件： vue子组件传递值的使用 子组件用到$emit给父组件响应，定义一个事件来触发响应的$emit使父组件可以知道有事件改变,进而接收对应的参数。 子组件： 父组件： 2.Vuex的基础使用 store的使用 import Vue from &apos;vue&apos; import Vuex from &apos;vuex&apos; Vue.use(Vuex) export default new Vuex.Store({ state: { //state就是Vuex中的公共的状态, 可以将state看作是所有组件的data, 用于保存所有组件的公共数据. }, getters: { // getters属性理解为所有组件的computed属性, 也就是计算属性. vuex的官方文档也是说到可以将getter理解为store的计算属性, getters的返回值会根据它的依赖被缓存起来，且只有 当它的依赖值发生了改变才会被重新计算。 }, mutations: { //将mutaions理解为store中的methods, mutations对象中保存着更改数据回调函数, 该函数名官方规定叫type, 第一个参数是state, 第二参数是payload, 也就是自定义的参数. 注意:调用mutaions中回调函数, 只能使用store.commit(type, payload) }, actions: { //actions 类似于 mutations，不同在于： actions提交的是mutations而不是直接变更状态 actions中可以包含异步操作, mutations中绝对不允许出现异步 actions中的回调函数的第一个参数是context, 是一个与store实例具有相同属性和方法的对象 其中minusPriceAsync采用setTimeout来模拟异步操作,延迟2s执行 该方法用于异步改变我们刚才在mutaions中定义的minusPrice 调用actions中回调函数, 只能使用store.dispatch(type, payload) }, modules: { //给全局变量分组，所以需要写提前声明其他store文件，然后引入这里 Vuex 允许我们将 store 分割成模块（module）。每个模块拥有自己的 state、mutation、action、getter、甚至是嵌套子模块——从上至下进行同样方式的分割 } }) watch和computed属性的使用例子 watch: { caseId () { this.personForm.caseId = this.caseId } }, computed: { caseId () { return this.$store.state.common.caseId //拿到store的值 } }, computed是计算属性，与data相似，但是具有缓存作用 watch起到监听作用 该例子为监听缓存中过的caseId 该段落只做摘要，具体参考[这篇文章](https://blog.csdn.net/garfielder007/article/details/83721038) 3.mounted与created的区别 created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。 mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。4.v-if与v-show v-if改变dom结构 v-show仅作视觉效果变化","link":"/2019/09/22/vue的常用总结/"}],"tags":[{"name":"el-element，控件","slug":"el-element，控件","link":"/tags/el-element，控件/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"el-element，json，vue，solt","slug":"el-element，json，vue，solt","link":"/tags/el-element，json，vue，solt/"},{"name":"json，对象序列化","slug":"json，对象序列化","link":"/tags/json，对象序列化/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"前端","slug":"前端","link":"/categories/前端/"},{"name":"CSS","slug":"CSS","link":"/categories/CSS/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"Vue","slug":"Vue","link":"/categories/Vue/"}]}